.program clk6502
.side_set 1

.define LOW    0
.define HIGH   1

.define READ   1
.define WRITE  0

.define OE1    0b011
.define OE2    0b101
.define OE3    0b110

  ;
  ; With a 6502 running at 2 MHz each period is 500 ns, for 250 ns per half-
  ; period (PHI2 low/high). With a 100 MHz PIO clock, we can fit 25 instructions
  ; into each PHI2 half-period, each instruction taking 10 ns excluding delays.
  ; We have space for 32 instructions.
  ;
  ; The side pin is used to generate the 2 MHz clock.
  ;
  ; Note the 74LVC245APW enable time of max 8.5 ns at 3.3V, or ~1 cycle,
  ; which we must honour.
  ;
  ; Upon a read request the Arm is given 190 ns to respond.
  ;
  ; L<nn> and H<nn> indicate where in the PHI2 L[ow] and H[igh] cycles we
  ; are, for <nn> in cycle # 00..24.
  ;

.wrap_target

L00:

  ;
  ; L00: Assume we'll be read from (1 cycle).
  ;
  set x, READ                   side LOW          ; set R/W flag

  ;
  ; L01: Prepare for reading address A0-A15 (14 cycles).
  ;
  mov osr, null                 side LOW          ; set OSR to 0x00000000
  out pindirs, 8                side LOW          ; set GPIO0-7 to inputs
  set pins, OE2                 side LOW [11]     ; enable /OE2 for A8-A15

  ;
  ; L15: Address now stable, read A0-A15 into ISR (4 cycles).
  ;
  in pins, 8                    side LOW          ; read A0-A7
  set pins, OE1                 side LOW [1]      ; enable /OE1 for A0-A7
  in pins, 8                    side LOW          ; read A8-A15

  ;
  ; L19: Save A0-A15 in Y and check R/W pin (2 cycles).
  ;
  mov y, isr                    side LOW          ; save A0-A15 in Y
  jmp pin, reading_from_us      side LOW          ; check R/W line

writing_to_us:

  ;
  ; L21: Prepare for being written to (4 cycles).
  ;
  set x, WRITE                  side LOW          ; set R/W to writing
  set pins, OE3                 side LOW [2]      ; enable /OE3 for D0-D7

  ;
  ; H00: Insert A0-A15 into ISR and wait (14 cycles).
  ;
  in y, 16                      side HIGH [13]    ; insert A0-A15 in ISR

  ;
  ; H14: Earliest moment that D0-D7 contains byte to write (1 cycle).
  ;
  in pins, 8                    side HIGH         ; read D0-D7

  ;
  ; H15: Auto-push to RX FIFO (1 cycle).
  ;
  in x, 1                       side HIGH         ; include write-bit, push

  ;
  ; H16: Waste remainder of PHI2-high period (9 cycles).
  ;
  jmp L00                       side HIGH [8]     ; move PHI2 low

reading_from_us:

  ;
  ; L21: Auto-push read request to RX FIFO (2 cycles).
  ;
  in null, 8                    side LOW          ; insert dummy byte in ISR
  in x, 1                       side LOW          ; include read-bit, push

  ;
  ; L23: Set GPIO0-7 to outputs and enable /OE3 (2 cycles).
  ;
  mov osr, ~ null               side LOW          ; set OSR to 0x11111111
  out pindirs, 8                side LOW          ; set GPIO0-7 to outputs

  ;
  ; H00: Wait to give Arm more time (17 cycles).
  ;
  set pins, OE3                 side HIGH         ; enable /OE3 for D0-D7
  nop                           side HIGH [15]    ; wait

  ;
  ; H17: Read Arm's response and output D0-D7, then wait 60 ns (8 cycles).
  ;
  pull block                    side HIGH         ; fetch from FIFO TX
  out pins, 8                   side HIGH [6]     ; write D0-D7, wait 60 ns

.wrap

% c-sdk {

#include "hardware/clocks.h"


#define PIN_OE1   8
#define PIN_OE2   9
#define PIN_OE3  10
#define PIN_RW   11
#define PIN_PHI2 21
#define PIN_IRQB 25
#define PIN_RESB 26
#define PIN_NMIB 27


static inline void clk6502_program_init(PIO pio, uint sm, uint offset) {
  // Initialise the NMIB, RESB and IRQB pins.
  gpio_init(PIN_NMIB);
  gpio_init(PIN_RESB);
  gpio_init(PIN_IRQB);

  // The NMIB, IRQB and RESB pins are always outputs.
  gpio_set_dir(PIN_NMIB, GPIO_OUT);
  gpio_set_dir(PIN_IRQB, GPIO_OUT);
  gpio_set_dir(PIN_RESB, GPIO_OUT);

  // Do not assert /IRQ nor /NMI.
  gpio_put(PIN_NMIB, 1);
  gpio_put(PIN_IRQB, 1);

  // Assert /RESET for at least two cycles, let the main program deassert it.
  gpio_put(PIN_RESB, 0);
  sleep_us(5);

  // Connect all relevant GPIO pins.
  const uint pins[] = {
    0, 1, 2, 3, 4, 5, 6, 7,  // D0-D7, A0-A7, A8-A15
    PIN_OE1, PIN_OE2, PIN_OE3,
    PIN_RW,
    PIN_PHI2
  };
  for (uint i = 0; i < count_of(pins); i++) {
    pio_gpio_init(pio, pins[i]);
  }

  // /OE1 to /OE3 are always outputs.
  pio_sm_set_consecutive_pindirs(pio, sm, PIN_OE1, 3, true);
  // R/W is always an input.
  pio_sm_set_consecutive_pindirs(pio, sm, PIN_RW, 1, false);
  // PHI2 is always an output.
  pio_sm_set_consecutive_pindirs(pio, sm, PIN_PHI2, 1, true);

  pio_sm_config c = clk6502_program_get_default_config(offset);

  // GPIO0-7 (D0-D7, A0-A15) are bidrectional pins.
  sm_config_set_in_pins(&c, 0);
  sm_config_set_out_pins(&c, 0, 8);

  // GPIO8-10 (/OE1 to /OE3) are set pins.
  sm_config_set_set_pins(&c, PIN_OE1, 3);

  // GPIO11 (R/W) is used to JMP on.
  sm_config_set_jmp_pin(&c, PIN_RW);

  // GPIO21 (PHI2) is the sideset pin.
  sm_config_set_sideset_pins(&c, PIN_PHI2);

  // Auto-push A0-A15 + D0-D7 + R/W to the RX FIFO, shifting left.
  sm_config_set_in_shift(&c, false, true, 16 + 8 + 1);

  // Manual pull D0-D7 from the TX FIFO, shifting left.
  sm_config_set_out_shift(&c, false, false, 8);
  
  // Need to run the statemachine at 100 MHz.
  const float div = clock_get_hz(clk_sys) / 100000000;
  sm_config_set_clkdiv(&c, div);

  // Start the statemachine.
  pio_sm_init(pio, sm, offset, &c);
  pio_sm_set_enabled(pio, sm, true);
}

%}
